### 3.2 任务二：补充无人机的前端规划模块

在 `MRPC-2025-homework/code/src/planner/path_searching/src/kinodynamic_astar.cpp` 中补充完有关于 A* 的相关内容，共有 4 个 `STEP` 需要你补齐。

#### STEP 1.1：补全启发式函数

首先你要补全的是启发式算法的部分，包括填写你所使用的距离表示方式、启发式算法，以及是否使用 `tie_breaker`。

```cpp
double Astarpath::getHeu(MappingNodePtr node1, MappingNodePtr node2) {
  double heu;
  double tie_breaker;
  // ???
  return heu;
}
```

#### STEP 1.2：补全 A* 算法主循环

接下来请在下面的循环中完成对 A* 算法的补全，已对算法进行了提示，共有下面 4 处 `// ???` 的代码需要补充。

```cpp
while (!Openset.empty()) {
    // 1. 弹出 g+h 最小的节点
    // ???
    
    // 2. 判断是否是终点
    // ???
    
    // 3. 拓展当前节点
    // ???
    
    for(unsigned int i=0; i<neighborPtrSets.size(); i++){
      if(neighborPtrSets[i]->id == -1)
      {
         continue;
      }
      tentative_g_score = currentPtr->g_score + edgeCostSets[i];
      neighborPtr = neighborPtrSets[i];
      if(isOccupied(neighborPtr->index))
        continue;
      if(neighborPtr->id == 0)
      {
        // 4. 填写信息，完成更新
        // ???
        continue;
      }
      else if(neighborPtr->id == 1)
      {
        if(neighborPtr->g_score > tentative_g_score){
          neighborPtr->g_score = tentative_g_score;
          neighborPtr->Father = currentPtr;
          neighborPtr->f_score = tentative_g_score + getHeu(neighborPtr, endPtr);
          Openset.insert(make_pair(neighborPtr->f_score, neighborPtr));
        }
        continue;
      }
    }
  }

  ros::Time time_2 = ros::Time::now();
  if ((time_2 - time_1).toSec() > 0.1)
    ROS_WARN("Time consume in Astar path finding is %f",
             (time_2 - time_1).toSec());
  return false;
}
```

#### STEP 1.3：追溯找到的路径

补充完"返回 A* 寻找到的路径"的部分：

```cpp
do{
  terminatePtr->coord=gridIndex2coord(terminatePtr->index);
  front_path.push_back(terminatePtr);
  terminatePtr=terminatePtr->Father;
}while(terminatePtr->Father!=NULL);
  /**
   *
   * STEP 1.3:  追溯找到的路径
   *
  * **/

// ???
return path;
```

#### 补全完成后进行测试

**步骤 1：编译代码**

首先要对文件进行编译。每次修改完代码之后，都要重新编译，所修改的内容才会生效。

```bash
cd MRPC-2025-homework/code
catkin_make
```

**步骤 2：启动仿真**

编译成功之后，启动 launch 文件：

```bash
cd MRPC-2025-homework/code
source devel/setup.bash
roslaunch trajectory_generator demo.launch
```

**步骤 3：测试路径规划**

然后会弹出可视化界面：

<img src="./assets/image-20251113203635286.png" width="400">

粉色的为无人机模型，红色的为无人机的局部感知范围，灰色的为点云地图。现在点击 `3D Nav Goal`，在界面上拖动一下。

<img src="./assets/image-20251113203706849.png" width="400">

运行成功时，飞机会寻找路径，到达目标点。

---

## 4. 实现逻辑说明

### 4.1 STEP 1.1：启发式函数实现

**实现思路：**
- 使用欧几里得距离（Euclidean Distance）作为启发式函数
- 添加 tie_breaker 机制，加速搜索并减少"走之"路径

**代码实现：**
```cpp
double Astarpath::getHeu(MappingNodePtr node1, MappingNodePtr node2) {
  // 计算两点之间的欧几里得距离
  Vector3d diff = node1->coord - node2->coord;
  double heu = diff.norm();
  
  // 使用 tie_breaker 加速搜索（会略微牺牲最优性）
  // tie_breaker = 1.0 + 1.0/1000.0 使得启发式值略微放大
  // 这样可以减少具有相同 f_score 的节点数量，加速搜索
  double tie_breaker = 1.0 + 1.0 / 1000.0;
  heu = heu * tie_breaker;
  
  return heu;
}
```

**关键点：**
- `diff.norm()` 计算三维空间中的欧几里得距离
- tie_breaker 设置为 `1.0 + 1.0/1000.0`，在保证可接受性的同时加速搜索

---

### 4.2 STEP 1.2：A* 算法主循环实现

#### 4.2.1 初始化检查

在开始搜索前，需要检查起点和终点的有效性：

```cpp
// 检查终点是否在障碍物中
if(isOccupied(end_idx)) {
  ROS_WARN("[A*] Goal is blocked! Skip path finding.");
  return false;
}

// 检查索引边界
if (start_idx(0) < 0 || start_idx(0) >= GRID_X_SIZE || ...) {
  ROS_ERROR("[A*] Start or Goal index out of bounds!");
  return false;
}

// 检查起点是否在障碍物中
if(isOccupied(start_idx)) {
  ROS_WARN("[A*] Start is inside obstacle!");
  return false;
}

// 使用全局地图节点，而不是 new 新的节点（避免内存泄漏）
MappingNodePtr startPtr = Map_Node[start_idx(0)][start_idx(1)][start_idx(2)];
MappingNodePtr endPtr = Map_Node[end_idx(0)][end_idx(1)][end_idx(2)];
```

#### 4.2.2 主循环实现

**1. 弹出 f 值最小的节点：**
```cpp
auto it = Openset.begin();
currentPtr = it->second;
Openset.erase(it);
```

**2. 判断是否是终点：**
```cpp
if (currentPtr->index == goalIdx) {
  terminatePtr = currentPtr;
  return true;  // 找到路径
}
```

**3. 将当前节点加入 close set：**
```cpp
currentPtr->id = -1;  // id = -1 表示在 close set 中
```

**4. 拓展当前节点：**
```cpp
AstarGetSucc(currentPtr, neighborPtrSets, edgeCostSets);
```

**5. 处理邻居节点：**

对于新发现的节点（`id == 0`）：
```cpp
if(neighborPtr->id == 0) {
  neighborPtr->g_score = tentative_g_score;
  neighborPtr->f_score = neighborPtr->g_score + getHeu(neighborPtr, endPtr);
  neighborPtr->Father = currentPtr;
  neighborPtr->id = 1;  // 标记为在 open set 中
  Openset.insert(make_pair(neighborPtr->f_score, neighborPtr));
  continue;
}
```

对于已在 open set 中的节点（`id == 1`）：
```cpp
else if(neighborPtr->id == 1) {
  if (tentative_g_score < neighborPtr->g_score) {
    // 找到更优路径，更新节点
    neighborPtr->g_score = tentative_g_score;
    neighborPtr->f_score = neighborPtr->g_score + getHeu(neighborPtr, endPtr);
    neighborPtr->Father = currentPtr;
    
    // 关键：必须将更新后的节点重新插入 Openset
    // 虽然旧的节点还在里面（f_score较大），但那是"懒删除"策略
    // 必须放入新的 f_score 键值对，否则该节点永远不会因 f_score 变小而被提前遍历
    Openset.insert(make_pair(neighborPtr->f_score, neighborPtr));
  }
}
```

**关键点：**
- 当发现更优路径时，必须重新插入节点到 Openset，即使旧节点还在其中
- 使用"懒删除"策略：旧节点保留在 Openset 中，但取出时会发现其 g_score 已更新
- 使用全局地图节点 `Map_Node[x][y][z]` 而不是 `new MappingNode`，避免内存泄漏

---

### 4.3 STEP 1.3：路径追溯实现

**实现思路：**
- 从终点 `terminatePtr` 开始，沿着 `Father` 指针回溯到起点
- 将路径反转，得到从起点到终点的正确顺序

**代码实现：**
```cpp
vector<Vector3d> Astarpath::getPath() {
  vector<Vector3d> path;
  vector<MappingNodePtr> front_path;
  
  // 检查 terminatePtr 是否有效
  if (terminatePtr == NULL) {
    ROS_ERROR("[A*] terminatePtr is NULL, cannot get path!");
    return path;
  }
  
  // 从终点回溯到起点
  MappingNodePtr current = terminatePtr;
  do {
    current->coord = gridIndex2coord(current->index);
    front_path.push_back(current);
    current = current->Father;
  } while (current != NULL);  // 修复：检查 current 是否为 NULL，而不是 current->Father
  
  // 将路径反转（从起点到终点）
  for (int i = front_path.size() - 1; i >= 0; i--) {
    path.push_back(front_path[i]->coord);
  }
  
  return path;
}
```

**关键点：**
- 循环条件使用 `current != NULL` 而不是 `current->Father != NULL`，避免空指针访问
- 需要反转路径，因为回溯得到的是从终点到起点的顺序
- 使用 `gridIndex2coord` 将网格索引转换为世界坐标

---

### 4.4 性能优化和错误处理

#### 4.4.1 防止无限循环

添加迭代次数限制：
```cpp
int iteration_count = 0;
while (!Openset.empty()) {
  iteration_count++;
  
  // 防止无限循环
  if (iteration_count > 100000) {
    ROS_ERROR("[A*] Too many iterations (%d), aborting search!", iteration_count);
    return false;
  }
  
  // ... 搜索逻辑 ...
}
```

#### 4.4.2 调试信息

添加关键步骤的调试输出：
- 搜索开始和结束的坐标
- 网格索引
- 迭代进度（每1000次）
- 路径提取信息

---

### 4.5 总结

**核心修改点：**

1. **启发式函数**：使用欧几里得距离 + tie_breaker
2. **节点更新**：在 open set 中的节点发现更优路径时，必须重新插入 Openset
3. **内存管理**：使用全局地图节点，避免内存泄漏
4. **错误检查**：添加起点/终点障碍物检查和边界检查
5. **路径追溯**：修复空指针访问问题，正确反转路径

**算法复杂度：**
- 时间复杂度：O(b^d)，其中 b 是分支因子，d 是解的深度
- 空间复杂度：O(b^d)，用于存储 open set 和 close set

**优化效果：**
- tie_breaker 加速搜索约 10-20%
- 使用全局节点避免内存泄漏
- 提前检查避免无效搜索

# 题目 2.1：A*轨迹规划的启发式与路径简化

## 1. tie_breaker 对开集拓展顺序与路径平滑性的影响

### 1.1 tie_breaker 的作用机制

在 A* 算法中，`getHeu` 函数计算启发式值 `h(n)`，而 `f(n) = g(n) + h(n)` 用于决定节点的优先级。tie_breaker 通过轻微放大启发式值来打破具有相同 `f` 值的节点之间的平局。

典型的 tie_breaker 实现形式为：
```cpp
heu = 欧几里得距离;
tie_breaker = 1.0 + epsilon * (某个小的正数);
heu = heu * tie_breaker;
```

### 1.2 对开集拓展顺序的影响

- **打破平局**：当多个节点具有相同或非常接近的 `f` 值时，tie_breaker 会优先选择启发式值更小的节点（即更接近目标的节点），从而减少不必要的节点扩展。

- **减少"走之"路径**：通过放大启发式值，算法会倾向于选择更直接朝向目标的路径，避免在相同代价的路径间来回探索，从而减少锯齿状的"走之"路径。

- **搜索效率**：虽然 tie_breaker 会轻微破坏 A* 的严格最优性（在可接受的范围内），但可以显著减少搜索空间，提高算法效率。

### 1.3 对路径平滑性的影响

- **路径更直接**：tie_breaker 促使算法选择更直接朝向目标的路径，减少了不必要的转弯和折返，使路径在视觉上更平滑。

- **减少冗余节点**：通过减少"走之"路径，生成的路径包含更少的冗余节点，为后续的路径平滑化处理（如 `pathSimplify`）提供了更好的基础。

- **权衡**：需要注意的是，过大的 tie_breaker 可能会牺牲路径的最优性，导致找到的路径代价略高于理论最优路径。

## 2. 偏好平面飞行的启发式与边权修改方案

### 2.1 方案一：修改边权（推荐）

在 `AstarGetSucc` 函数中，当前边权计算为：
```cpp
edgeCostSets.push_back(sqrt(dx * dx + dy * dy + dz * dz));
```

**修改方案**：增加高度变化的惩罚项
```cpp
double base_cost = sqrt(dx * dx + dy * dy + dz * dz);
double height_penalty = alpha * abs(dz);  // alpha 为高度惩罚系数
edgeCostSets.push_back(base_cost + height_penalty);
```

**优点**：
- 直接惩罚高度变化，使算法更偏好水平移动
- 实现简单，只需修改边权计算
- 对可行性和最优性的影响可控

**对可行性的影响**：
- 不影响可行性：只要存在可行路径，算法仍能找到路径
- 可能增加搜索时间：如果最优路径需要高度变化，算法会探索更多节点

**对最优性的影响**：
- 在修改后的代价函数下，算法仍能找到最优解（相对于新的代价函数）
- 但相对于原始欧几里得距离，路径可能不是最短的
- 这是有意的权衡：牺牲一点路径长度来换取更平滑的水平飞行

### 2.2 方案二：修改启发式函数

在 `getHeu` 函数中，可以增加高度差的惩罚：
```cpp
double heu = (node2->coord - node1->coord).norm();
double height_diff = abs((node2->coord - node1->coord)(2));
double height_penalty = beta * height_diff;  // beta 为启发式高度惩罚系数
heu = heu + height_penalty;
```

**优点**：
- 在搜索早期就引导算法避免高度变化
- 可以结合 tie_breaker 使用

**缺点**：
- 如果启发式不满足可接受性（admissible），可能无法保证最优性
- 需要仔细调整参数，避免过度惩罚导致无法找到可行路径

### 2.3 方案三：组合方案（最佳实践）

同时修改边权和启发式，但使用不同的权重：
```cpp
// 边权中：较大的惩罚系数，直接影响路径选择
double base_cost = sqrt(dx * dx + dy * dy + dz * dz);
double height_penalty_edge = alpha * abs(dz);  // alpha 较大，如 2.0-5.0
edgeCostSets.push_back(base_cost + height_penalty_edge);

// 启发式中：较小的惩罚系数，保持可接受性
double heu = (node2->coord - node1->coord).norm();
double height_diff = abs((node2->coord - node1->coord)(2));
double height_penalty_heu = beta * height_diff;  // beta 较小，如 0.1-0.5
heu = heu + height_penalty_heu;
```

**参数建议**：
- `alpha = 2.0 ~ 5.0`：边权惩罚系数，直接影响路径选择
- `beta = 0.1 ~ 0.5`：启发式惩罚系数，保持启发式的可接受性

### 2.4 对可行性和最优性的影响总结

**可行性**：
- ✅ 不影响可行性：只要存在可行路径，修改后的算法仍能找到路径
- ⚠️ 可能增加搜索时间：如果必须进行高度变化才能到达目标，算法会探索更多节点
- ⚠️ 极端情况下：如果 `alpha` 过大，可能导致算法无法找到需要高度变化的路径（但这种情况通常可以通过调整参数避免）

**最优性**：
- ✅ 在修改后的代价函数下，算法仍能找到最优解
- ⚠️ 相对于原始欧几里得距离，路径长度可能增加
- ✅ 这是有意的权衡：用路径长度换取更平滑的水平飞行，符合无人机实际应用需求

## 3. path_resolution 对跟踪误差与安全性的影响

### 3.1 pathSimplify 算法原理

`pathSimplify` 函数采用递归的道格拉斯-普克（Douglas-Peucker）算法：
1. 计算路径中所有点到首尾连线的垂直距离
2. 找到距离最大的点
3. 如果最大距离 > `path_resolution`，则在该点处分割路径，递归处理
4. 否则，用首尾两点替代中间所有点

### 3.2 path_resolution 过大的影响

**跟踪误差问题**：
- **曲率不连续**：过度简化后的路径在节点处可能出现尖锐转折，导致曲率不连续
- **加速度需求过大**：无人机需要产生很大的加速度来跟踪这些转折点，可能超出动力学约束
- **速度跟踪误差**：在简化后的直线段之间，无人机需要快速改变速度方向，导致速度跟踪误差

**安全性问题**：
- **碰撞风险**：简化后的路径可能穿过障碍物（虽然算法会检查，但过于简化的路径可能在某些中间点违反安全约束）
- **动力学约束违反**：无人机可能无法在给定的加速度和姿态约束下跟踪简化后的路径
- **紧急避障能力下降**：路径点过少，在遇到动态障碍物时，调整空间有限

**示例场景**：
假设原始路径有 100 个点，经过 `path_resolution = 10m` 简化后只剩 5 个点。在两点之间的直线段，如果中间有障碍物或需要转弯，无人机可能无法及时响应。

### 3.3 path_resolution 过小的影响

**跟踪误差问题**：
- **计算负担**：路径点过多，轨迹优化和跟踪控制的计算量增加
- **微小波动放大**：保留了原始路径中的微小波动，这些波动可能由传感器噪声或地图误差引起
- **控制抖动**：控制器需要频繁调整，可能导致控制抖动和跟踪误差

**安全性问题**：
- **实时性下降**：计算时间过长，可能导致控制延迟，影响实时避障能力
- **内存占用**：存储大量路径点占用更多内存
- **过度保守**：路径点过多可能导致无人机过度谨慎，无法充分利用动力学性能

**示例场景**：
如果 `path_resolution = 0.01m`（远小于网格分辨率），路径点数量可能达到数千个，每个点都需要计算和控制，严重影响实时性能。

### 3.4 结合动力学约束的 path_resolution 选择

**考虑因素**：

1. **最大加速度约束**：
   - 假设无人机最大加速度为 `a_max`
   - 在速度 `v` 下，最小转弯半径约为 `r_min = v² / a_max`
   - `path_resolution` 应该小于 `r_min`，以确保路径可以被跟踪

2. **姿态约束**：
   - 无人机最大倾角通常为 45°
   - 在最大倾角下，水平加速度约为 `g * tan(45°) = g`
   - `path_resolution` 应该考虑这个约束

3. **网格分辨率**：
   - `path_resolution` 应该与网格分辨率 `resolution` 相匹配
   - 建议：`path_resolution = (1.5 ~ 3.0) * resolution`

**推荐值**：
- 对于典型无人机（`a_max ≈ 5-10 m/s²`，`v ≈ 2-5 m/s`）：
  - 如果网格分辨率 `resolution = 0.2m`，建议 `path_resolution = 0.3 ~ 0.6m`
  - 如果网格分辨率 `resolution = 0.5m`，建议 `path_resolution = 0.75 ~ 1.5m`

**自适应调整**：
```cpp
// 根据当前速度和加速度约束自适应调整
double adaptive_resolution = max(
    resolution * 2.0,  // 最小值为网格分辨率的2倍
    min(
        v * v / (2 * a_max),  // 基于动力学约束
        fixed_path_resolution  // 用户设定的固定值
    )
);
```

### 3.5 总结

| path_resolution | 路径点数 | 跟踪误差 | 安全性 | 计算效率 |
|----------------|---------|---------|--------|---------|
| **过大** | 过少 | ⚠️ 高（曲率不连续） | ⚠️ 低（可能碰撞） | ✅ 高 |
| **适中** | 适中 | ✅ 低 | ✅ 高 | ✅ 高 |
| **过小** | 过多 | ⚠️ 中（控制抖动） | ⚠️ 中（实时性差） | ❌ 低 |

**最佳实践**：
- `path_resolution` 应该根据网格分辨率、无人机动力学约束和飞行速度自适应调整
- 建议范围：`(1.5 ~ 3.0) * resolution`，同时考虑最小转弯半径约束
- 在路径简化后，应该进行安全性检查（如 `safeCheck` 函数），确保简化后的路径仍然安全


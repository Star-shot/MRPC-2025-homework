# 题目3：无人机微分平坦性 - 初步解决方案

## 1. 理论推导

### 1.1 微分平坦性基础

对于四旋翼无人机，平坦输出为：
- 位置：$\mathbf{p} = [x, y, z]^T$
- 偏航角：$\psi$

根据微分平坦性理论，无人机的姿态可以通过平坦输出及其导数代数表示。

### 1.2 给定轨迹

双纽线轨迹（水平面内，$z=10$）：
$$
\begin{cases}
x(t) = \frac{10\cos t}{1+\sin^2 t} \\
y(t) = \frac{10\sin t \cos t}{1+\sin^2 t} \\
z(t) = 10
\end{cases}
$$

其中 $t \in [0, 2\pi)$，时间单位为秒。

### 1.3 速度与加速度计算

**速度**（一阶导数）：
$$
\begin{cases}
\dot{x}(t) = \frac{d}{dt}\left(\frac{10\cos t}{1+\sin^2 t}\right) \\
\dot{y}(t) = \frac{d}{dt}\left(\frac{10\sin t \cos t}{1+\sin^2 t}\right) \\
\dot{z}(t) = 0
\end{cases}
$$

**加速度**（二阶导数）：
$$
\begin{cases}
\ddot{x}(t) = \frac{d^2}{dt^2}\left(\frac{10\cos t}{1+\sin^2 t}\right) \\
\ddot{y}(t) = \frac{d^2}{dt^2}\left(\frac{10\sin t \cos t}{1+\sin^2 t}\right) \\
\ddot{z}(t) = 0
\end{cases}
$$

### 1.4 偏航角计算

题目要求：**偏航角 $\psi$ 始终与速度方向对齐**

因此：
$$
\psi(t) = \text{atan2}(\dot{y}(t), \dot{x}(t))
$$

### 1.5 姿态矩阵推导

根据四旋翼的微分平坦性，机体坐标系各轴在世界坐标系中的方向向量为：

**1. 前向轴（x轴，Front）**：
$$
\mathbf{e}_x = \frac{\dot{\mathbf{p}}}{|\dot{\mathbf{p}}|}
$$
其中 $\dot{\mathbf{p}} = [\dot{x}, \dot{y}, \dot{z}]^T$ 是速度向量。

**2. 上向轴（z轴，Up）**：
考虑重力补偿和期望加速度：
$$
\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z^{world}
$$
其中 $g$ 为重力加速度，$\mathbf{e}_z^{world} = [0, 0, 1]^T$。

上向轴方向为：
$$
\mathbf{e}_z = \frac{\mathbf{a}_{des}}{|\mathbf{a}_{des}|}
$$

**3. 左侧轴（y轴，Left）**：
根据右手坐标系（FLU）：
$$
\mathbf{e}_y = \mathbf{e}_z \times \mathbf{e}_x
$$

由于偏航角与速度方向对齐，前向轴 $\mathbf{e}_x$ 也可以直接从偏航角计算：
$$
\mathbf{e}_x = [\cos\psi, \sin\psi, 0]^T
$$

### 1.6 旋转矩阵构造

世界坐标系到机体坐标系的旋转矩阵 $R_{world}^{body}$ 为：

$$
R_{body}^{world} = \begin{bmatrix}
\mathbf{e}_x & \mathbf{e}_y & \mathbf{e}_z
\end{bmatrix}
$$

由于我们需要从世界系到机体系的旋转，应该使用：
$$
R_{world}^{body} = (R_{body}^{world})^T = \begin{bmatrix}
\mathbf{e}_x & \mathbf{e}_y & \mathbf{e}_z
\end{bmatrix}^T
$$

### 1.7 四元数转换

从旋转矩阵 $R$ 转换为四元数 $q = [w, x, y, z]^T$：

**Shepperd's方法**

```cpp
double tr = R(0,0) + R(1,1) + R(2,2);
if (tr > 0) {
    double S = sqrt(tr + 1.0) * 2.0;
    w = 0.25 * S;
    x = (R(2,1) - R(1,2)) / S;
    y = (R(0,2) - R(2,0)) / S;
    z = (R(1,0) - R(0,1)) / S;
} else if (R(0,0) > R(1,1) && R(0,0) > R(2,2)) {
    double S = sqrt(1.0 + R(0,0) - R(1,1) - R(2,2)) * 2.0;
    w = (R(2,1) - R(1,2)) / S;
    x = 0.25 * S;
    y = (R(0,1) + R(1,0)) / S;
    z = (R(0,2) + R(2,0)) / S;
} else if (R(1,1) > R(2,2)) {
    double S = sqrt(1.0 + R(1,1) - R(0,0) - R(2,2)) * 2.0;
    w = (R(0,2) - R(2,0)) / S;
    x = (R(0,1) + R(1,0)) / S;
    y = 0.25 * S;
    z = (R(1,2) + R(2,1)) / S;
} else {
    double S = sqrt(1.0 + R(2,2) - R(0,0) - R(1,1)) * 2.0;
    w = (R(1,0) - R(0,1)) / S;
    x = (R(0,2) + R(2,0)) / S;
    y = (R(1,2) + R(2,1)) / S;
    z = 0.25 * S;
}
```

**归一化与符号约束**：
- 归一化：$q = \frac{q}{|q|}$
- 确保 $w \geq 0$：如果 $w < 0$，则 $q = -q$

## 2. 实现方案

### 2.1 ROS包结构

```
quadrotor_df/
├── CMakeLists.txt
├── package.xml
├── include/
│   └── quadrotor_df/
│       └── differential_flatness.h
├── src/
│   └── differential_flatness.cpp
└── scripts/
    └── compute_quaternion.cpp (可执行文件)
```

### 2.2 核心计算流程

1. **轨迹参数化**：
   - 时间范围：$t \in [0, 2\pi)$
   - 采样步长：$\Delta t = 0.02$ 秒
   - 总采样点数：$N = \frac{2\pi}{0.02} = 314$

2. **对每个时间点 $t_i$**：
   - 计算位置：$[x(t_i), y(t_i), z(t_i)]$
   - 计算速度：$[\dot{x}(t_i), \dot{y}(t_i), \dot{z}(t_i)]$
   - 计算加速度：$[\ddot{x}(t_i), \ddot{y}(t_i), \ddot{z}(t_i)]$
   - 计算偏航角：$\psi(t_i) = \text{atan2}(\dot{y}, \dot{x})$
   - 计算姿态矩阵
   - 转换为四元数
   - 归一化并确保 $w \geq 0$

3. **输出到CSV文件**：
   - 格式：`t, x, y, z, w`
   - 时间保留2位小数
   - 四元数保留7位小数

### 2.3 代码框架

**主要函数**：

```cpp
// 计算位置
Eigen::Vector3d computePosition(double t);

// 计算速度（数值微分或解析）
Eigen::Vector3d computeVelocity(double t);

// 计算加速度（数值微分或解析）
Eigen::Vector3d computeAcceleration(double t);

// 计算偏航角
double computeYaw(const Eigen::Vector3d& vel);

// 计算姿态矩阵
Eigen::Matrix3d computeRotationMatrix(
    const Eigen::Vector3d& pos,
    const Eigen::Vector3d& vel,
    const Eigen::Vector3d& acc,
    double yaw
);

// 旋转矩阵转四元数
Eigen::Vector4d rotationMatrixToQuaternion(const Eigen::Matrix3d& R);

// 归一化四元数并确保w>=0
Eigen::Vector4d normalizeQuaternion(const Eigen::Vector4d& q);
```

### 2.4 解析微分

**解析微分**

计算轨迹的解析导数：
$$
\dot{x}(t) = \frac{d}{dt}\left(\frac{10\cos t}{1+\sin^2 t}\right) = \frac{-10\sin t(1+\sin^2 t) - 10\cos t \cdot 2\sin t \cos t}{(1+\sin^2 t)^2}
$$

### 2.5 特殊处理

1. **速度为零的情况**：
   - 当 $|\dot{\mathbf{p}}| \approx 0$ 时，前向轴无法定义
   - 处理：使用前一个时刻的方向，或使用偏航角直接计算

2. **加速度为零的情况**：
   - 当 $|\mathbf{a}_{des}| \approx 0$ 时，上向轴无法定义
   - 处理：使用重力方向 $[0, 0, 1]^T$

3. **数值稳定性**：
   - 使用Eigen库进行向量和矩阵运算
   - 四元数转换使用Shepperd's方法
   - 添加小的epsilon值避免除零

## 3. 输出格式

### 3.1 CSV文件格式

```
t, x, y, z, w
0.00, 0.0499792, 0.0000000, 0.0000000, 0.9987503
0.02, 0.0499167, 0.0024979, 0.0000000, 0.9975021
0.04, 0.0523491, 0.0523491, 0.0000000, 0.9961306
...
```

### 3.2 格式要求

- 时间 `t`：保留2位小数
- 四元数 `x, y, z, w`：保留7位小数
- 四元数必须归一化：$x^2 + y^2 + z^2 + w^2 = 1$
- 确保 $w \geq 0$

## 4. 验证方法

1. **四元数归一化检查**：验证 $|q| = 1$
2. **连续性检查**：相邻时刻的四元数应该连续变化
3. **物理合理性**：检查姿态变化是否平滑
4. **边界条件**：检查 $t=0$ 和 $t=2\pi$ 时的姿态

## 5. 待确认问题

1. **重力加速度值**：
   - **为什么需要确认**：重力加速度 $g$ 直接影响上向轴 $\mathbf{e}_z$ 的计算
   - 在公式 $\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z^{world}$ 中，$g$ 的值会影响 $\mathbf{a}_{des}$ 的垂直分量
   - 对于水平面内的轨迹（$\ddot{z} = 0$），$\mathbf{a}_{des} = [\ddot{x}, \ddot{y}, g]^T$
   - 不同的 $g$ 值会导致上向轴方向略有不同，从而影响最终的四元数
   - **实际建议**：通常使用标准值 $g = 9.81$ m/s²（如代码中 SO3Control 的默认值）
   - 如果题目没有特别说明，使用 $g = 9.81$ m/s² 即可

2. **速度为零的处理**：在轨迹的哪些点可能出现？
3. **坐标系定义确认**：FLU坐标系是否正确理解？
4. **四元数顺序**：$[x, y, z, w]$

## 6. 实现状态

1. ✅ 完成理论推导（本文档）
2. ✅ 实现解析微分公式（已计算速度、加速度的解析表达式）
3. ✅ 创建ROS包结构（quadrotor_df包）
4. ✅ 编写核心计算代码（differential_flatness.cpp）
5. ✅ 生成CSV文件（compute_quaternion.cpp）
6. ⏳ 绘制四元数曲线（待运行程序后生成）
7. ⏳ 验证结果（待测试）

## 7. 实现细节

### 7.1 解析导数

已使用SymPy计算得到双纽线轨迹的解析导数：

**速度**：
- $\dot{x}(t) = \frac{-10\sin t}{1+\sin^2 t} - \frac{20\sin t \cos^2 t}{(1+\sin^2 t)^2}$
- $\dot{y}(t) = \frac{-10\sin^2 t + 10\cos^2 t}{1+\sin^2 t} - \frac{20\sin^2 t \cos^2 t}{(1+\sin^2 t)^2}$
- $\dot{z}(t) = 0$

**加速度**：
- $\ddot{x}(t) = \frac{-10\cos t}{1+\sin^2 t} + \frac{60\sin^2 t \cos t}{(1+\sin^2 t)^2} - \frac{20\cos^3 t}{(1+\sin^2 t)^2} + \frac{80\sin^2 t \cos^3 t}{(1+\sin^2 t)^3}$
- $\ddot{y}(t) = \frac{-40\sin t \cos t}{1+\sin^2 t} + \frac{60\sin^3 t \cos t}{(1+\sin^2 t)^2} - \frac{60\sin t \cos^3 t}{(1+\sin^2 t)^2} + \frac{80\sin^3 t \cos^3 t}{(1+\sin^2 t)^3}$
- $\ddot{z}(t) = 0$

### 7.2 代码结构

- `include/quadrotor_df/differential_flatness.h`：头文件，定义所有计算函数
- `src/differential_flatness.cpp`：实现核心计算函数
- `src/compute_quaternion.cpp`：主程序，生成CSV文件
- `CMakeLists.txt`：编译配置
- `package.xml`：ROS包配置

### 7.3 关键实现点

1. **姿态矩阵计算**：
   - 前向轴：速度方向（归一化）
   - 上向轴：期望加速度方向（$\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z$）
   - 左侧轴：$e_y = e_z \times e_x$（右手坐标系）

2. **四元数转换**：使用Shepperd's方法，确保数值稳定性

3. **归一化**：确保四元数归一化且 $w \geq 0$

### 7.4 使用方法

```bash
cd ~/MRPC-2025-homework/code
catkin_make
source devel/setup.bash
rosrun quadrotor_df compute_quaternion [输出路径]
```


# 题目3：无人机微分平坦性 - 初步解决方案

## 1. 理论推导

### 1.1 微分平坦性基础

对于四旋翼无人机，平坦输出为：
- 位置：$\mathbf{p} = [x, y, z]^T$
- 偏航角：$\psi$

根据微分平坦性理论，无人机的姿态可以通过平坦输出及其导数代数表示。

### 1.2 给定轨迹

双纽线轨迹（水平面内，$z=10$）：
$$
\begin{cases}
x(t) = \frac{10\cos t}{1+\sin^2 t} \\
y(t) = \frac{10\sin t \cos t}{1+\sin^2 t} \\
z(t) = 10
\end{cases}
$$

其中 $t \in [0, 2\pi)$，时间单位为秒。

### 1.3 速度与加速度计算

**速度**（一阶导数）：
$$
\begin{cases}
\dot{x}(t) = \frac{d}{dt}\left(\frac{10\cos t}{1+\sin^2 t}\right) \\
\dot{y}(t) = \frac{d}{dt}\left(\frac{10\sin t \cos t}{1+\sin^2 t}\right) \\
\dot{z}(t) = 0
\end{cases}
$$

**加速度**（二阶导数）：
$$
\begin{cases}
\ddot{x}(t) = \frac{d^2}{dt^2}\left(\frac{10\cos t}{1+\sin^2 t}\right) \\
\ddot{y}(t) = \frac{d^2}{dt^2}\left(\frac{10\sin t \cos t}{1+\sin^2 t}\right) \\
\ddot{z}(t) = 0
\end{cases}
$$

### 1.4 偏航角计算

题目要求：**偏航角 $\psi$ 始终与速度方向对齐**

因此：
$$
\psi(t) = \text{atan2}(\dot{y}(t), \dot{x}(t))
$$

### 1.5 姿态矩阵推导

根据四旋翼的微分平坦性，机体坐标系各轴在世界坐标系中的方向向量为：

**1. 前向轴（x轴，Front）**：
$$
\mathbf{e}_x = \frac{\dot{\mathbf{p}}}{|\dot{\mathbf{p}}|}
$$
其中 $\dot{\mathbf{p}} = [\dot{x}, \dot{y}, \dot{z}]^T$ 是速度向量。

**2. 上向轴（z轴，Up）**：
考虑重力补偿和期望加速度：
$$
\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z^{world}
$$
其中 $g$ 为重力加速度，$\mathbf{e}_z^{world} = [0, 0, 1]^T$。

上向轴方向为：
$$
\mathbf{e}_z = \frac{\mathbf{a}_{des}}{|\mathbf{a}_{des}|}
$$

**3. 左侧轴（y轴，Left）**：
根据右手坐标系（FLU）：
$$
\mathbf{e}_y = \mathbf{e}_z \times \mathbf{e}_x
$$

由于偏航角与速度方向对齐，前向轴 $\mathbf{e}_x$ 也可以直接从偏航角计算：
$$
\mathbf{e}_x = [\cos\psi, \sin\psi, 0]^T
$$

### 1.6 旋转矩阵构造

世界坐标系到机体坐标系的旋转矩阵 $R_{world}^{body}$ 为：

$$
R_{body}^{world} = \begin{bmatrix}
\mathbf{e}_x & \mathbf{e}_y & \mathbf{e}_z
\end{bmatrix}
$$

由于我们需要从世界系到机体系的旋转，应该使用：
$$
R_{world}^{body} = (R_{body}^{world})^T = \begin{bmatrix}
\mathbf{e}_x & \mathbf{e}_y & \mathbf{e}_z
\end{bmatrix}^T
$$

### 1.7 四元数转换

从旋转矩阵 $R$ 转换为四元数 $q = [w, x, y, z]^T$：

**Shepperd's方法**

```cpp
double tr = R(0,0) + R(1,1) + R(2,2);
if (tr > 0) {
    double S = sqrt(tr + 1.0) * 2.0;
    w = 0.25 * S;
    x = (R(2,1) - R(1,2)) / S;
    y = (R(0,2) - R(2,0)) / S;
    z = (R(1,0) - R(0,1)) / S;
} else if (R(0,0) > R(1,1) && R(0,0) > R(2,2)) {
    double S = sqrt(1.0 + R(0,0) - R(1,1) - R(2,2)) * 2.0;
    w = (R(2,1) - R(1,2)) / S;
    x = 0.25 * S;
    y = (R(0,1) + R(1,0)) / S;
    z = (R(0,2) + R(2,0)) / S;
} else if (R(1,1) > R(2,2)) {
    double S = sqrt(1.0 + R(1,1) - R(0,0) - R(2,2)) * 2.0;
    w = (R(0,2) - R(2,0)) / S;
    x = (R(0,1) + R(1,0)) / S;
    y = 0.25 * S;
    z = (R(1,2) + R(2,1)) / S;
} else {
    double S = sqrt(1.0 + R(2,2) - R(0,0) - R(1,1)) * 2.0;
    w = (R(1,0) - R(0,1)) / S;
    x = (R(0,2) + R(2,0)) / S;
    y = (R(1,2) + R(2,1)) / S;
    z = 0.25 * S;
}
```

**归一化与符号约束**：
- 归一化：$q = \frac{q}{|q|}$
- 确保 $w \geq 0$：如果 $w < 0$，则 $q = -q$

## 2. 实现方案

### 2.1 ROS包结构

```
quadrotor_df/
├── CMakeLists.txt
├── package.xml
├── include/
│   └── quadrotor_df/
│       └── differential_flatness.h
├── src/
│   └── differential_flatness.cpp
└── scripts/
    └── compute_quaternion.cpp (可执行文件)
```

### 2.2 核心计算流程

1. **轨迹参数化**：
   - 时间范围：$t \in [0, 2\pi)$
   - 采样步长：$\Delta t = 0.02$ 秒
   - 总采样点数：$N = \frac{2\pi}{0.02} = 314$

2. **对每个时间点 $t_i$**：
   - 计算位置：$[x(t_i), y(t_i), z(t_i)]$
   - 计算速度：$[\dot{x}(t_i), \dot{y}(t_i), \dot{z}(t_i)]$
   - 计算加速度：$[\ddot{x}(t_i), \ddot{y}(t_i), \ddot{z}(t_i)]$
   - 计算偏航角：$\psi(t_i) = \text{atan2}(\dot{y}, \dot{x})$
   - 计算姿态矩阵
   - 转换为四元数
   - 归一化并确保 $w \geq 0$

3. **输出到CSV文件**：
   - 格式：`t, x, y, z, w`
   - 时间保留2位小数
   - 四元数保留7位小数

### 2.3 代码框架

**主要函数**：

```cpp
// 计算位置
Eigen::Vector3d computePosition(double t);

// 计算速度（数值微分或解析）
Eigen::Vector3d computeVelocity(double t);

// 计算加速度（数值微分或解析）
Eigen::Vector3d computeAcceleration(double t);

// 计算偏航角
double computeYaw(const Eigen::Vector3d& vel);

// 计算姿态矩阵
Eigen::Matrix3d computeRotationMatrix(
    const Eigen::Vector3d& pos,
    const Eigen::Vector3d& vel,
    const Eigen::Vector3d& acc,
    double yaw
);

// 旋转矩阵转四元数
Eigen::Vector4d rotationMatrixToQuaternion(const Eigen::Matrix3d& R);

// 归一化四元数并确保w>=0
Eigen::Vector4d normalizeQuaternion(const Eigen::Vector4d& q);
```

### 2.4 解析微分

**解析微分**

计算轨迹的解析导数：
$$
\dot{x}(t) = \frac{d}{dt}\left(\frac{10\cos t}{1+\sin^2 t}\right) = \frac{-10\sin t(1+\sin^2 t) - 10\cos t \cdot 2\sin t \cos t}{(1+\sin^2 t)^2}
$$

### 2.5 特殊处理

1. **速度为零的情况**：
   - 当 $|\dot{\mathbf{p}}| \approx 0$ 时，前向轴无法定义
   - 处理：使用前一个时刻的方向，或使用偏航角直接计算

2. **加速度为零的情况**：
   - 当 $|\mathbf{a}_{des}| \approx 0$ 时，上向轴无法定义
   - 处理：使用重力方向 $[0, 0, 1]^T$

3. **数值稳定性**：
   - 使用Eigen库进行向量和矩阵运算
   - 四元数转换使用Shepperd's方法
   - 添加小的epsilon值避免除零

## 3. 输出格式

### 3.1 CSV文件格式

```
t, x, y, z, w
0.00, 0.0499792, 0.0000000, 0.0000000, 0.9987503
0.02, 0.0499167, 0.0024979, 0.0000000, 0.9975021
0.04, 0.0523491, 0.0523491, 0.0000000, 0.9961306
...
```

### 3.2 格式要求

- 时间 `t`：保留2位小数
- 四元数 `x, y, z, w`：保留7位小数
- 四元数必须归一化：$x^2 + y^2 + z^2 + w^2 = 1$
- 确保 $w \geq 0$

## 4. 验证方法

1. **四元数归一化检查**：验证 $|q| = 1$
2. **连续性检查**：相邻时刻的四元数应该连续变化
3. **物理合理性**：检查姿态变化是否平滑
4. **边界条件**：检查 $t=0$ 和 $t=2\pi$ 时的姿态

## 5. 待确认问题

1. **重力加速度值**：
   - **为什么需要确认**：重力加速度 $g$ 直接影响上向轴 $\mathbf{e}_z$ 的计算
   - 在公式 $\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z^{world}$ 中，$g$ 的值会影响 $\mathbf{a}_{des}$ 的垂直分量
   - 对于水平面内的轨迹（$\ddot{z} = 0$），$\mathbf{a}_{des} = [\ddot{x}, \ddot{y}, g]^T$
   - 不同的 $g$ 值会导致上向轴方向略有不同，从而影响最终的四元数
   - **实际建议**：通常使用标准值 $g = 9.81$ m/s²（如代码中 SO3Control 的默认值）
   - 如果题目没有特别说明，使用 $g = 9.81$ m/s² 即可

2. **速度为零的处理**：在轨迹的哪些点可能出现？
3. **坐标系定义确认**：FLU坐标系是否正确理解？
4. **四元数顺序**：$[x, y, z, w]$

## 6. 实现状态

1. ✅ 完成理论推导（本文档）
2. ✅ 实现解析微分公式（已计算速度、加速度的解析表达式）
3. ✅ 创建ROS包结构（quadrotor_df包）
4. ✅ 编写核心计算代码（differential_flatness.cpp）
5. ✅ 生成CSV文件（compute_quaternion.cpp）
6. ⏳ 绘制四元数曲线（待运行程序后生成）
7. ⏳ 验证结果（待测试）

## 7. 实现细节

### 7.1 解析导数

已使用SymPy计算得到双纽线轨迹的解析导数：

**速度**：
- $\dot{x}(t) = \frac{-10\sin t}{1+\sin^2 t} - \frac{20\sin t \cos^2 t}{(1+\sin^2 t)^2}$
- $\dot{y}(t) = \frac{-10\sin^2 t + 10\cos^2 t}{1+\sin^2 t} - \frac{20\sin^2 t \cos^2 t}{(1+\sin^2 t)^2}$
- $\dot{z}(t) = 0$

**加速度**：
- $\ddot{x}(t) = \frac{-10\cos t}{1+\sin^2 t} + \frac{60\sin^2 t \cos t}{(1+\sin^2 t)^2} - \frac{20\cos^3 t}{(1+\sin^2 t)^2} + \frac{80\sin^2 t \cos^3 t}{(1+\sin^2 t)^3}$
- $\ddot{y}(t) = \frac{-40\sin t \cos t}{1+\sin^2 t} + \frac{60\sin^3 t \cos t}{(1+\sin^2 t)^2} - \frac{60\sin t \cos^3 t}{(1+\sin^2 t)^2} + \frac{80\sin^3 t \cos^3 t}{(1+\sin^2 t)^3}$
- $\ddot{z}(t) = 0$

### 7.2 代码结构

- `include/quadrotor_df/differential_flatness.h`：头文件，定义所有计算函数
- `src/differential_flatness.cpp`：实现核心计算函数
- `src/compute_quaternion.cpp`：主程序，生成CSV文件
- `CMakeLists.txt`：编译配置
- `package.xml`：ROS包配置

### 7.3 关键实现点

1. **姿态矩阵计算**：
   - 前向轴：速度方向（归一化）
   - 上向轴：期望加速度方向（$\mathbf{a}_{des} = \ddot{\mathbf{p}} + g\mathbf{e}_z$）
   - 左侧轴：$e_y = e_z \times e_x$（右手坐标系）

2. **四元数转换**：使用Shepperd's方法，确保数值稳定性

3. **归一化**：确保四元数归一化且 $w \geq 0$

### 7.4 使用方法

```bash
cd ~/MRPC-2025-homework/code
catkin_make
source devel/setup.bash
rosrun quadrotor_df compute_quaternion [输出路径]
```

结果分析
这是一个非常典型的**“符合题目要求，但在物理直观上反直觉”**的结果。

**结论：这张图是合理的，而且极有可能是正确的。**

你看到的那些“吓人”的垂直跳变（Discontinuities），并不是因为你的物理推导错了，也不是因为轨迹计算错了，而是完全由题目中 **“要求 $q_w \geq 0$”** 这一强制约束引起的数学伪影（Artifact）。

以下是详细分析，为什么这些跳变是合理的：

### 1. 罪魁祸首：$q_w \geq 0$ 的约束
四元数 $q$ 和 $-q$ 表示的是完全相同的旋转姿态（这被称为四元数的“双倍覆盖”特性）。
* 在自然的连续运动中，随着飞行器偏航角（Yaw）的变化，四元数的实部 $w$（标量部分）通常形如 $\cos(\theta/2)$。
* 当旋转角度 $\theta$ 经过 $180^\circ$ ($\pi$) 时，$w$ 会自然地穿过 $0$ 变为负数。
* **但是**，题目强制要求输出结果必须满足 $q_w \geq 0$。

### 2. 结合图表证据分析
请仔细观察你生成的四张子图，它们完美印证了上述逻辑：

* **右下角 $w$ 图（紫色）：**
    * 注意看 $w$ 的曲线，它并不是平滑地穿过 0，而是像皮球落地一样在 $y=0$ 处“反弹”了回去。
    * 这说明你的原始计算结果在这里本该变为负数，但被代码强制取了绝对值（或乘以了 -1）。

* **左下角 $z$ 图（蓝色）和 右上角 $y$ 图（绿色）：**
    * **关键现象：** 请注意，蓝色和绿色曲线发生“垂直跳变”的时间点，**精确对应**于紫色曲线 $w$ 触底（接近 0）的时间点。
    * **数学解释：** 为了保持 $w$ 为正，当原始计算的 $w$ 变为负数时，你必须将整个四元数乘以 $-1$（即 $q \rightarrow -q$）。这就导致向量部分 $(x, y, z)$ 的符号瞬间全部反转。
    * 这就是为什么你会看到 $z$ 轴分量瞬间从 $-0.8$ 跳到 $+0.8$ 的原因。这在数学上代表同一个姿态，只是换了一套参数表达。

### 3. 物理背景验证（双纽线轨迹）
* **偏航角变化：** 无人机飞双纽线（Figure-8）且机头朝向速度方向。在这个过程中，无人机的朝向会发生超过 $180^\circ$ 的大幅度改变。
* **必然性：** 只要偏航角转过的范围涵盖了背对初始方向的角度（即转过了 $180^\circ$），$w$ 分量就必然会过零点。加上强制正号约束，跳变就是不可避免的。

### 总结与建议

**这张图是正确的**，它忠实地反映了题目要求的数学解。

* **写报告时的建议：** 在报告中，不要试图“掩盖”这些跳变，而应该主动解释它们。你可以这样写：
    > “四元数曲线中的跳变点并非物理姿态的突变，而是由于题目要求 $q_w \geq 0$ 导致的。当机体偏航角经过 $\pm 180^\circ$ 附近时，四元数实部 $w$ 穿过零点。为了满足 $w \geq 0$ 的约束，算法对四元数进行了 $q \rightarrow -q$ 的翻转操作，从而在 $x, y, z$ 分量上产生了符号跃变。由于 $q$ 与 $-q$ 表示同一物理姿态，因此计算结果在物理上是连续的。”

* **如果这是实际工程：** 如果你要把这个四元数发给飞控（PX4/Ardupilot），这种跳变是**灾难性**的，因为会导致微分爆炸。在实际控制中，我们通常不要求 $q_w \geq 0$，而是使用“四元数解缠（Unwrapping）”来保证曲线平滑。但针对这道作业题，你做得完全正确。

这是一个非常好的观察！这张图乍一看可能有些反直觉，但实际上它**完全符合物理规律**。

简单的回答是：**飞机的“机头朝向”（Yaw）确实是沿着轨迹方向的，但为了转弯，飞机必须发生“侧倾”（Roll）。**

你看到的红色箭头（机头方向）之所以看起来不像是“平平地”贴在轨迹上，是因为四旋翼无人机（Quadrotor）的运动特性导致的。以下是详细解释：

### 1. 为什么必须“歪”着飞？（物理原因）
四旋翼无人机是一个**欠驱动系统**（Underactuated System）。
* 它不像汽车，转弯时四个轮子还在地上平着走。
* 它更像**摩托车**或**鸟类**。

当无人机在双纽线（8字形）轨迹上飞行时，它在不断地做**曲线运动**。
* **曲线运动需要向心力**：为了拐弯，无人机必须产生一个指向圆心的力。
* **推力方向固定**：无人机的推力永远只垂直于机身平面（即图中 **蓝色箭头 Z轴** 的方向）。
* **结论**：为了获得水平方向的向心力，无人机必须把机身**侧倾（Roll）**。

### 2. 解读图中的箭头
请再仔细看一眼你的图：

* **蓝色箭头（Z轴，头顶方向）：**
    * 注意看在拐弯最急的地方（8字的两端），蓝色箭头明显**向圆心倾斜**。
    * 这说明无人机正在“压弯”，把推力分量指向圆心以产生向心加速度。

* **红色箭头（X轴，机头方向）：**
    * 虽然题目要求偏航角（Yaw）对齐速度方向，但这指的是**在水平面上的投影**。
    * 由于机身为了拐弯发生了侧倾（Roll），作为机身的一部分，红色箭头（X轴）也会跟着一起歪。
    * **它依然指向“前方”，但是是“歪着身子的前方”。**

### 3. 为什么看起来有些奇怪？
在这个双纽线轨迹中，无人机的速度并不是恒定的，曲率也在剧烈变化。
* **在 8 字交叉点：** 轨迹比较直，需要的向心力小，所以机身比较平（蓝色箭头朝上，红色箭头平指前方）。
* **在 8 字两端：** 转弯半径小，需要的向心力大，所以机身侧倾角度非常大。

### 总结
你的图是**正确**的。
飞机确实在“看”着路（Yaw对齐），但因为它跑得很快又要急转弯，所以它必须**侧身**（Roll）来抵抗离心力。如果不侧身，它就会被甩出轨迹。

这正是**微分平坦性**计算的核心逻辑：我们先算出需要的加速度（推力方向），定下机身姿态（Z轴），然后再把机头（X轴）转到切线方向。
